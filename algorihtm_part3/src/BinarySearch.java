/**
 * 코테에 많이 나오는 문제들!!!!!
 * 정형화된 코드를 외울때까지 공부해야해!!
 *
 * 이분탐색 --> 반드시!! 정렬된 상태!!!!!
 * 정렬이 된 배열에서 해당 배열을 반으로 나누면서
 * 중앙값과 키값을 비교해가면서 배열을 반씩 자르면서 탐색한다.
 *
 * 오른차순 정렬이 되어 있다면?
 * 임의의 인덱스(M) 속 값 > 키값 : M보다 작은 인덱스에서 키값이 발견된다.
 * 임의의 인덱스(M) 속 값 < 키값 : M보다 큰 인덱스에서 키값이 발견된다.
 *
 * 예시 1)
 * x 이하의 원소 중에 가장 오른쪽에 있는 원소는 ? 혹은 x보다 작은 수들의 갯수는? 이런문제 풀기가능
 *
 * 시간 복잡도
 * 정렬이 되어있다는 가정하에
 * 총 비교 횟수는 O(logN)이 된다.
 *
 * 이분탐색_기초 백준
 * 7795번. (유사문제 : 1920, 1764, 3273, 10816)
 * 정답의 최대치
 * 20000개 20000개
 * 20000*20000 => 4억개 => int형 사용 가능!
 *
 * B배열을 정렬을 하고
 * A의 모든 원소를 정렬된 B배열에서 이분탐색으로 검색한다.
 *
 * 2470번
 * 서로다른 용액(양수, 음수들의 조합)이 있다면
 * 두 수를 찾아서 더할 때 합이 최대한 0에 가깝게 만드는 문제
 *
 * 가장 쉬운 방법
 * -> 두 용액을 모두 선택해서 다 더해보는 것
 *
 * 빠른 방법
 * 한 용액, A[왼쪽]값을 골랐다면 -A[왼쪽] 이 수와 가장 가까운 수를 골라서 더해주면 좋아욤!~
 *
 * 정렬의 특성.. 각 원소마다 가장 가까운 값은 인접해있다.
 * -> 일단 주어진 값을 정렬해보자.
 *
 * 이분 탐색 응용편 -> 매개변수(파라메타) 서치
 *
 * 매개 변수 탐색 ---->>**문제를 뒤집어서 보는 생각하는 발상이 아주 중요하다!**
 * ~의 최댓값을, 최솟값을 구하시오!라는 말을 봤는데 방법이 생각이 안난다? -> 매개 변수 탐색 시도!
 * <예시>
 * 1. 00000000111111이렇게 오면 0과 1이 구분되는 그 순간을 찾는 문제!
 * 2. 1~1000사이에 랜덤으로 뽑힌 수 찾기
 *
 * <핵심>
 * 정답을 매개 변수로 만들고 yes/no (결정 문제)로 바꿔보기
 * 모든 값은 정렬된 상태여야하고, yes/no로 그 기준으로 찾는다.
 *
 * 문제를 거꾸로 푸는 것이므로 중요하다..-> 코테에 많이 나오는 유형
 *
 * 문제 : 2805 (유사 1654, 2512), 2110, 2343, 6236, 13702, 17266  (고난이도 : 1300,1637)
 *
 * 백준 : 2805
 * 나무 자르기 -> 나무 갯수 4개,  필요한 나무의 길이 7m
 *
 * 문제 파악하기 -> 정답의 최대치
 * 정답 범위가 0~10억
 * 잘린 나무의 길이 합 <= 나무 높이의 총합(100만*10억) ---> long 자료현 사용해야 한다.
 * 정답은 int형인데... 계산 과정에서 long이 필요한다.
 *
 * 원래 문제 : 원하는 길이 M만큼 얻을 수 있는 최대 높이는 얼마인가?
 *
 * 뒤집은 문제 (결정 문제) :
 * 어떤 높이로 잘랐을 때, 원하는 길이만큼을 얻을 수 있는가? --> yes/no 문제로!
 *
 * 2110번
 * 공유기 설치
 *
 * 원래 문제 : c개의 공유기를 설치했을 때, 최대 인접 거리는 얼마인가?
 *
 * 뒤집은 문제 : 어떤 거리 만큼은 거리를 둘 때, 공유기 c개를 설치할 수 있는가?
 *
 * 시간 복잡도
 * 1. 주어진 집들 정렬하기 NlogN
 * 2. D를 정해서 결정문제 한번에 풀기 N
 * 3. 정답의 범위를 이분탐색하면서 풀기 logX
 * --> O(NlogN + NlogX)
 *
* */
public class BinarySearch {

}
