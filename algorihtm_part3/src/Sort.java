/**
 * 1초동안 1억개의 자료 처리가능!
 * 그리고 배열이나 변수들을 전역변수로 설정해두는 것은 좋은 아이디어인 것 같음..!!
 *
 * 정렬
 * 오름차순 : 크기가 점점 커지게!
 * 내림차순 : 크기가 점점 작아지게!
 *
 * 정렬은...
 * 1. 조건이 필요하다(오름차순, 내림차순)
 * 구현은
 * implements Comparable<Elem>
 *     int item
 *     public int compareTo(Elem e){
 *         return this.item - e.item; // 이러면 오름차순
 *     }
 *
 * 2. 시간 복잡도는 약 O(NlogN)이다.
 *  primitive 원소 정렬
 *  (int, double, char.. 등등)
 *  Dual-Pivot Quick Sort (퀵 소트) -> inplace 정렬
 *
 *  Object 원소 정렬
 *  Tim Sort (선택 + 병합 정렬) -> stable
 *
 *  3. In-place / Stable
 *  1) In-place
 *  정렬 알고리즘이 제자리 한가?
 *  정렬하는 과정에서 N에 비해 충분히 무시할 만한 개수의 메모리만큼만 추가적으로 사용하는가?
 *
 *  2) Stable
 *  정렬알고리즘이 안정한가?
 *  동등한 위상의 원소들의 순서 관계가 보존되는가?
 *
 *  정렬 기초 백준
 *  10825
 *  implements Comparalbe<Item>안의 compareTo()함수 적극적으로 사용하기
 *
 *  정렬 응용 백준
 *  1015번
 *
 *  방법 1)
 *  가장 쉬운 방법 (시간복잡도 O(N^2)
 *  크기가 작기 때문에 배열을 다 찾아서 값을 연결해서 P배열을 만들어준다.
 *
 *  방법 2)
 *  A -> P -> B이므로 A 배열 속 인덱스에서 P의 인덱스의 값을 가지고 A로 가는것 이기 때문에
 *  P[idx] = b_idx 이런식으로 처리해주어도 된다.
 *
 *  우선 배열을 정렬하고 (O(NlogN)) -> p 배열 구한다. (O(N))
 *  시간 복잡도 : O(NlogN), 공간 복잡도 : O(N)
 *
 *  11652번 ( 20291번)과 유사!!
 *  ----->> 해쉬 테이블을 사용할 수도 있다..
 *  하지만... 정렬의 특성 중 값이 같은 수는 인접해 있다라는 사실을 이용해야하는 문제가 종종 있으므로
 *  이 방법대로 풀어보자!!
 *
 *  주어진 숫자들 중 최빈값 출력하기 -> 만약 최빈값이 여러개라면 작은 값을 반환하다.
 *
 *  기초 생각 : 그냥 노가다로 처음부터 쭉 탐색하면 되니까안 -> 근데 시간복잡도가....말이 안된다..
 *
 *  류호석 생각 :
 *      카드를 정렬해서 현재 값과 다음값에 대한 카드를 비교해서 같으면 중복된 카드구나! 다르면 아 새로나온 카드네?하면서 갯수를 파악해나간다.
 *      current Count : 지금 보고 있는 카드가 등장한 횟수
 *      Mode count : 지금까지의 최빈값 등장 횟수
 *      Mode : 지금까지의 최빈값 ( 최고 많이 등장한 카드의 수)
 *  시간, 공간 복잡도
 *      배열 정렬 : O(NlogN) _ 시간 복잡도
 *      Counting : O(N) _ 공간 복잡도
 *
 *  주어진 숫자를 보고서 문제를 읽을 때 부터 어떤 데이터타입을 쓸지!! 체크!! 필요!!
 *  -> 시간을 많이 줄일 수 있다!!
 *
 *  15970번 (어려운 문제!!)
 *
 *  정답의 최대치 구하기 (데이터 타입을 결정하기 위해서)
 *  점 두개 -> 2*10^5만큼의 화살표 길이
 *  색마다 이런 점들이 있다면 5000/2쌀만큼 표현가능
 *
 *  즉 모든 점마다 10만 만큼의 길이를 갖는 화살표를 그리는 경우리ㅡㅁ로
 *  정답의 최대치는 2*10^5 * 5000/2 = 5 * 10^8
 *  --> int 자료형으로 사용해도 무방하겠군!!
 *
 *  각 원소마다, 가장 가까운 원소는 자신의 양옆에 있다!라는 아이디어를 사용하자.
 *
 *  내 처음 생각
 *  점들의 색과 위치를 담고 있는 클래스를 만든다..
 *  그리고 색별로 오름차순으로 정렬을 하고 같은 색은 위치별로 또 오름차순 정렬을 한다.
 *  그 후에 같은 색끼리 양 옆에 있는거를 한다..
 *  --> 근데 이렇게 되면 결국 위의 11652번 문제처럼 같은 색상의 묶음을 먼저 파악을 해서 관리해야하므러
 *  정렬을 쓰는 큰 메리트가 없어지는 것 같다
 *
 *  ...그래서 류호석의 풀이는??
 *  같은 색깔별로 Arraylist를 먼저 만들어서 (색이 N개 이므로 리스트도 N개를 만든다.)
 *  ArrayList <Integer> [] colorList = new ArrayList[N+1] --> 요런식으로 표현
 *  그리고 그 배열안에는 해당되는 색깔에 맞게 리스트에 위치 정보를 저장한다.
 *  그리고 그 배열들을 각각 정렬해서 자신과 가장 가까운 점까지의 거리를 찾으면 될 것 같다.
*
* */
public class Sort {
}
