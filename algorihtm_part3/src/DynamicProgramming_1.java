/**
 * 동적 프로그래밍 (DunamicProgramming)
 * 문제의 크기를 변화하면서 정답을 계산하는데,
 * 작은 문제의 결과를 이용해서 큰 문제의 정답을 빠르게 계산하는 알고리즘!
 *
 * 문제푸는 방식..
 * 문제가 원하는 정답을 찾기 위해 완전 탐색 접근을 시도한다.
 * 근데 탐색할게 너무 많다? => 모든 경우를 빠르게 탐색하는 방법으로 DP를 써보자!
 *
 * 1. 풀고 싶은 가짜 문제를 정의한다.
 * 2. 가짜 문제를 풀면 진짜 문제를 풀 수 있는가? 판단을 한다.
 * 3. 가짜 문제에 대해서 초기값은 어떻게 설정할래?
 * 4. 작은 문제들의 결과를 이용해서 점화식을 구해낸다.
 * 5. 진짜 문제 정답 출력하기
 *
 * 9095번 (1,2,3 더하기)
 * 정수 n이 주어졌을 때, n을 1,2,3의 합으로 나타내는 방법의 수
 * (단, 숫자의 순서가 다를 경우 다른 식이라고 생각한다)
 *
 * 우선 완전 탐색으로 해보자 (백트래킹 이용)
 *     문제 : N이 커질수록 탐색해야 하는 경우가 많다 ==> DP?
 *
 * 1. 풀고 싶은 가짜 문제 정의하기
 *      팁 > 일단 진짜 문제 먼저 써보자
 *      이 문제에서의 가짜문제
 *      dy[i] => i를 1,2,3의 합으로 표현하는 경우의 수
 *
 * 2. 가짜 문제를 풀면 진짜 문제를 풀 수 있는가?
 *      네
 *
 * 3. 초기값은 어떻게 되는가?
 *      초기값 : 쪼개지 않아도 풀 수 있는 "작은 문제"뜰에 대한 정답
 *      이 초기값은 노가다를 사용해본다.
 *      dy[1] = 1
 *      dy[2] = 2
 *      dy[3] = 4
 *
 * 4. 점화식을 계산해보자 (DP에서 가장 어려운 부분!)
 *      팁 >
 *      1) dy[i] 계산에 필요한 탐색 경우의 공통점끼리 묶어내자
 *          1+1+1+1+1 1+2+1+1 ... 마지막에 어떤 숫자가 나왔는지를 공통으로 묶어보자자 *
 *      묶어낸 부분의 정답을 dy배열을 이용해서 빠르게 계산하자
 *
 *      i가 5라면
 *      part1 : 마지막 수가 1인 것
 *      1 1 1 1 1
 *      1 1 2 1
 *      1 2 1 1
 *      2 1 1 1
 *      1 3 1
 *      3 1 1
 *
 *      part2 : 마지막 수가 2인 것
 *      1 1 1 2
 *      1 2 2
 *      2 1 2
 *      3 2
 *
 *      part3 : 마지막 수가 3인 것
 *      1 1 3
 *      2 3
 *
 *      위와 같이 나눈다...그리고 각 파티션의 갯수들을 더하자!
 *      그럼 작은 문제로 쪼갰으니깐, 모든 i에 대해 각 파티션을 구해내는 것이 포인트!
 *
 *      마지막 부분이 1이여야된다?
 *      만약 i = 5라면..
 *      마지막 부분이 1이니깐,,
 *      part1 부분은 합이 i-1일 때 경우의 수
 *      part2 부분은 합이 i-2일 때 경우의 수
 *      part3 부분은 합이 i-3일 때 경우의 수
 *
 *      오! 그럼 점화식은...!!!
 *      dy[i] = dy[i-1] + dy[i-2] + dy[i-3]
 *
 *      이 dp 연습을 더 많이 해보자..!
 *
 * -------------쉬운 것 부터 차근차근!!.... 점화식을 유도하는 방식이 너무 중요해보여요!----------------
 *
 * 11726번 (2xN 타일링)
 *
 * N이 주어지면
 * 2xN 크기의 타일을 직사각형 1x2, 2x1 타일로 채우는 방법의 수를 수하는 프로그램을 작성해보자.
 *
 * 우선 완전탐색으로 문제를 풀어볼까요? => N이 커지면 감당이 안될 것 같아요!
 *
 * 1. 풀고 싶은 가짜 문제 정의
 *      가짜문제.. dy[i] => 2xi 타일에 타일링을 해보자!
 *
 * 2. 가짜 문제를 풀면 진짜 문제를 풀 수 있는가?
 *      네
 *
 * 3. 초기값은 어떻게 되는가?
 *      초기값 : 쪼개지 않아도 풀 수 있는 "작은 문제"뜰에 대한 정답
 *      이 초기값은 노가다를 사용해본다.
 *      dy[1] = 1
 *      dy[2] = 2
 *
 * 4. 점화식을 계산해보자 (DP에서 가장 어려운 부분!)
 *     dy[i] 계산에 필요한 탐색의 경우를 공통점끼리 묶어 내기
 *
 *     이번에는 가장 오른쪽 타일이..
 *     part1_ 2x1이 두개로 구성
 *          이렇게 끝에 두개를 무시하면..
 *          2 x (i-2) 크기의 타일을 구하는 것과 동일
 *
 *     part2_ 1x2 타일 한개로 구성
 *     i를 하나 정해서 손으로 그려볼까요?
 *          이렇게 끝에 한개를 무시하면..
 *          2 x (i-1) 크기의 타일을 구하는 것과 동일
 *
 *     점화식으로 표현하면..
 *     dy[i] = dy[i-1] + dy[i-2]
 *
 *
 * 즉, 동적 프로그래밍 문제는 공통점끼리 묶어내면 되겠다!
 * 그리고 초기값 2~3개는 직접 구해서 지정해줍니다.
 *
 * 1003
 * 10870
 * 15988
 * 15991
 * 11052
 * 2011
 * */
public class DynamicProgramming_1 {

}
