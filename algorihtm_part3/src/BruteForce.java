/**
 * 완전 탐색
 * 문제를 해결하기 위해 모든 경우를 전부 탐색하는 방법
 * for문이아닌 백트래킹, 재귀용법을 사용할 예정
 *
 * 코테에 나오는 완전 탐색 종류
 * N개 중 ( 중복을 허용해서, 중복없이)
 * M개를 ( 순서 있게 나열하기, 고르기)
 *
 * 재귀함수 구현 형태가
 *  if M개를 다 봤어? : 조건에 맞는 탐색 성공
 *  else k번째부터 M번째 원소를 조건에 맞게 고르자!
 *
 * void 함수 (int k){}
 *
 * case 1)N개 중 중복을 허용해서 M개를 순서있게 나열하기
 * 백준 : 15651
 *
 * case 2)N개 중 중복없이 M개를 순서있게 나열하기
 * 백준 : 15649
 *
 * case 3)N개 중 중복을 허용해서 M개를 고르기(비내림차순)
 * 백준 : 15652
 *
 * case 4)N개 중 중복없이 M개를 순서있게 나열하기
 * 백준 : 15650
 *
 * 이 4가지 케이스에 대해서 경우를 나누고 각각의 시간복잡도를 계속 생각하자.
 *
 * 응용편
 * 완전탐색 코테버전!
 * 백준 : 14888
 * 이 문제는 카드를 중복없이, 순서있게 나열하는 문제!
 *
 * 문제 조건을 보고 나올 수 있는 최대, 최소값을 파악해서 데이터타입을 선탣한다.
 *
 * NQUEEN (백트래킹의 전형적인 문제)
 * 백준 : 9663
 * N개 중에서 중복을 허용해서 N개를 순서대호 나열하는 경우의 수
 * 행 + 열의 값이 같은 애들은 / 이 방향으로 대각선으로 만날 수 있는 애들
 * 행 - 열의 값이 같은 애들은 \ 이 방향으로 대각선으로 만날 수 있는 애들
 *
 * 이 문제는 -> 가능성이 있는 위치에만 퀸을 놓자!
 *
 * 부분 수열의 합
 * 백준 : 1182
 *
 * 백트래킹킹 */

public class BruteForce {

}
