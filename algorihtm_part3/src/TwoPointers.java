/**
 * 아이디어> 정답을 위해 봐야하는 모든 영역에서 꼭 봐야하는 위치들만 찾아서 보자
 *
 * 투포인터
 * 화살표 두 개에 의미를 부여해서 탐색 범위를 압축
 *
 * 1. 1차원 배열 위 2개의 포인터를 표현하는 경우
 *      1) 2개의 포인터가 모두 왼쪽에서 시작헤서 같은 방향으로 이동
 *      2) 2개의 포인터가 양 끝에서 서로를 향해 이동동 *
 *
 * 2. 두 변수를 각각의 포인터로 표현하는 경우
 *
 * <꿀팁>
 *   - 1차원 배열에서의 "연속 부분 수열", "순서를 지키며 차례대로"
 *   - 곱의 최소
 *   위의 말이 언급되면 투포인터를 고려해보자.
 *
 * 백준 문제
 * 1806 -> 연속된 두 수의 부분 합합
 * L : 구간의 왼쪽 끝
 * R : 구간의 오른쪽 끝
 * sum : 구간의 합
 *
 * 2003, 2559, 15565, 11728, 2230 -> 백준 투 포인터 문제
 *
 * 2470 두용액
 * L : 남아있는 것들 중 가장 작은 원소
 * R : 남아있는 것들 중 가장 큰 원소
 *
 * 최대 + 최소 < 0
 *      최소 입장에서 최선책을 만났다! -> 그 이상으로 0과 가까운 수가 나올 수 없다, 최소 삭제!
 *
 * 최대 + 촤소 > 0
 *      최대 입장에서 최선책을 만났다 -> 그 이상으로 0과 가까울 수 없다. 최대 삭제
 *
 * L == R
 *      상황 종료
 *
 * 매순간 최대 최소를 찾아야 한다.
 * 그러니깐 일단 정렬을 하자!
 * 가장 작은 원소, 큰 원소를 바로 찾을 수 있다.
 *
 * 3273 문제도 풀어보기
 *
 * 13144 문제
 * **전체적인 아이디어로는 기준에 본 결과가 이미 보장되어 있으므로 또 볼 필요 없다라는 점이 아이디어!**
 * counting 배열을 하나 두고
 *
 * 1253 문제
 * 두 용액 문제랑 비슷비슷!!
 *
 * 2473번도 풀어보기!
 *
 * 16472번 - 고냥이
 * cnt라는 배열을 이용하자.
 * L : 인식가능한 가장 왼쪽 위치
 * R : 인식하고 싶은 구간의 오른쪽 끝
 *
 * * */
public class TwoPointers {
}
